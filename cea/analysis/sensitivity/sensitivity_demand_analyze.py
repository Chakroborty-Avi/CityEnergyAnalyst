"""
Analyze the results in the samples folder and write them out to an Excel file. This script assumes:

- a samples folder with the files `samples.npy` and `problem.pickle` was created with `sensitivity_demand_samples.py`
- all the results have been added to the sammples folder in the format `result.%i.csv`, with `%i` replaced by the index
  into the samples array. Use the script `sensitivity_demand_simulate.py` to create the results.
- each result file has the same list of columns (the `--output-parameters` for the simulations were the same)
- the `analyze_sensitivity` function is called with the same method and arguments as the sampling routine
  (`sensitivity_demand_samples.py`).
"""
import os
import numpy as np
import pickle

import pandas as pd
from SALib.analyze import sobol
from SALib.analyze import morris

__author__ = "Jimeno A. Fonseca; Daren Thomas"
__copyright__ = "Copyright 2016, Architecture and Building Systems - ETH Zurich"
__credits__ = ["Jimeno A. Fonseca", "Daren Thomas"]
__license__ = "MIT"
__version__ = "0.1"
__maintainer__ = "Daren Thomas"
__email__ = "thomas@arch.ethz.ch"
__status__ = "Production"


def analyze_sensitivity(samples_path, method, parameters):
    """
    Run the analysis for each output parameter. The exact function to use is selected by the `method` parameter:
    Use "morris" for `SALib.analyze.morris` and "sobol" for `SALib.analyze.sobol`.

    The samples folder `samples_path` contains the results of running a simulation with `sensitivity_demand_simulate.py`
    for each sample generated by `sensitivity_demand_samples.py`.

    PARAMETERS
    ----------

    :param samples_path: the path to the samples folder as created by `sensitivity_demand_samples.py`
    :type samples_path: str

    :param method: either "morris" or "sobol" depending on the sampling method used when the samples folder was
                   created (by `sensitivity_demand_samples.py`)
    :type method: str

    :param parameters: keyword arguments for the SALib analysis function. Valid keys:
                       - method == "morris": 'grid_jump' (int), 'num_levels' (int)
                       - method == "sobol": 'calc_second_order' (bool)
    :type parameters: dict
    """
    assert method in ('sobol', 'morris'), "Invalid analysis method: %s" % method

    with open(os.path.join(args.samples_folder, 'problem.pickle'), 'r') as f:
        problem = pickle.load(f)

    # this refers to `X` in the morris method: The NumPy matrix containing the model inputs
    samples = np.load(os.path.join(samples_path, 'samples.npy'))
    samples_count = len(samples)

    simulation_results = read_results(samples_path, samples_count)

    # each results file has the same shape, with one building per row. get the row count from the first result
    buildings_num = simulation_results[0].shape[0]

    writer = pd.ExcelWriter(os.path.join(samples_path, 'analysis_%s_%i.xls' % (method, samples_count)))

    # each results file has the same shape, with one output parameter per column. get the output parameters from the
    # first result
    output_parameters = list(simulation_results[0].columns[1:])

    # choose which analysis function to use and the list of keys in the analysis output to store
    if method == 'sobol':
        analysis_variables = 'S1', 'ST', 'ST_conf'
        analysis_function = sobol_analyze_function
    else:
        # method == 'morris'
        analysis_variables = 'mu_star', 'sigma', 'mu_star_conf'
        analysis_function = morris_analyze_function

    for output_parameter in output_parameters:
        # run the analysis for the given output parameter and write a worksheet for each analysis variable
        analysis_results = []
        for building in range(buildings_num):
            # `Y` is a NumPy array containing the model outputs as used in the SALib analyze functions
            Y = np.array([result.loc[building, output_parameter] for result in simulation_results])
            result = analysis_function(problem, samples, Y, parameters)
            analysis_results.append(result)

        # write out a worksheet for each analysis result (e.g. 'S1', 'ST', 'ST_conf' for method == 'sobol')
        for analysis_variable in analysis_variables:
            worksheet_name = "%(output_parameter)s_%(analysis_variable)s" % locals()
            building_results = [result[analysis_variable] for result in analysis_results]
            pd.DataFrame(building_results, columns=problem['names']).to_excel(writer, worksheet_name)
    writer.save()


def sobol_analyze_function(problem, _, Y, parameters):
    """
    Use the SALib.analyze.sobol method to analyze the simulation results.

    :param problem: The definition of the problem statement as defined for the sampling method.
    :param _: placeholder for the `X` parameter of the morris method not used for sobol
    :param Y: The NumPy array containing the model outputs
    :param parameters: dictionary containing the key 'calc_second_order' with a bool value to be passed to the
                       SALib.analyze.morris `calc_second_order` parameter.
    :return: returns the result of the SALib.analyze.sobol method (from the documentation: a dictionary with keys
             `S1`, `S1_conf`, `ST`, and `ST_conf`, where each entry is a list of size D (the number of parameters)
             containing the indices in the same order as the parameter file. If calc_second_order is True, the
             dictionary also contains keys `S2` and `S2_conf`.)
    """
    return sobol.analyze(problem, Y, calc_second_order=parameters['calc_second_order'])


def morris_analyze_function(problem, X, Y, parameters):
    """
    Use the SALib.analyze.morris method to analyze the simulation results.

    :param problem: The definition of the problem statement as defined for the sampling method.
    :param X: the `X` parameter of the morris method (The NumPy matrix containing the model inputs)
    :param Y: The NumPy array containing the model outputs
    :param parameters: dictionary containing the keys 'grid_jump' and 'num_levels' that are passed on to the
                       SALib.analyze.morris method parameters of the same name.
    :return: returns the result of the SALib.analyze.sobol method (from the documentation: a dictionary with keys 
             `mu`, `mu_star`, `sigma`, and `mu_star_conf`, where each entry is a list of size D (the number of eters) 
             containing the indices in the same order as the parameter file.)
    """
    return morris.analyze(problem, X, Y,
                          grid_jump=parameters['grid_jump'], num_levels=parameters['num_levels'])


def read_results(samples_folder, samples_count):
    """
    Read each `results.%i.csv` file from the samples folder into a DataFrame and return them as a list. Each such
    csv file has a column for each output parameter specified for the simulation runs and a row for each building.

    PARAMETERS
    ----------

    :param samples_folder: path to the samples folder containing the results files of the simulation runs
    :type samples_folder: str

    :param samples_count: the total number of `results.%i.csv` files in the samples folder. Use
                          `sensitivity_demand_count.py` to calculate this for a given samples folder.
    :type samples_count: int

    RETURNS
    -------

    :returns: A list of DataFram objects representing each result of a simulation.
    :rtype: list of DataFrame

    INPUT / OUTPUT FILES
    --------------------

    - `$samples_folder/result.$i.csv` for i in range(samples_count)
    """
    results = []
    for i in range(samples_count):
        result_file = os.path.join(samples_folder, 'result.%i.csv' % i)
        df = pd.read_csv(result_file)
        results.append(df)
    return results


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('-S', '--samples-folder', default='.',
                        help='folder to place the output files (samples.npy, problem.pickle) in')
    parser.add_argument('-m', '--method', help='Method to use valid values: "morris" (default), "sobol"',
                        default='morris')
    parser.add_argument('--calc-second-order', help='(sobol) calc_second_order parameter', type=bool,
                        default=False)
    parser.add_argument('--grid-jump', help='(morris) grid_jump parameter', type=int,
                        default=2)
    parser.add_argument('--num-levels', help='(morris) num_levels parameter', type=int,
                        default=4)
    args = parser.parse_args()

    # valid parameters to pass to the sampler method vary between methods, based on the method used, create
    # a dictionary with the parameters.
    sampler_params = {}
    if args.method == 'morris':
        sampler_params['grid_jump'] = args.grid_jump
        sampler_params['num_levels'] = args.num_levels
    elif args.method == 'sobol':
        sampler_params['calc_second_order'] = args.calc_second_order

    analyze_sensitivity(samples_path=args.samples_folder, method=args.method, parameters=sampler_params)
